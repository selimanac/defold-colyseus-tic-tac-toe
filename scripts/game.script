local ColyseusClient = require "colyseus.client"

local client
local room
local numPlayers = 0
local gui_controller = msg.url("game", hash("/gui"), "game")

--GUI den gelecek mesaja göre gönderilecek.
local function onSelect(_x, _y)
	room:send({x = _x, y = _y})
end

local function showWinner(clientId)
	pprint(clientId)
	room:leave()
	local result = (room.sessionId == clientId) and true or false
	msg.post(gui_controller, "Winners", {won = result})
end

local function drawGame()
	room:leave()
	--game end screen Eşit
end
local function nextTurn(self)
	local result = (self.change_value == room.sessionId) and 1 or 0
	msg.post(gui_controller, "ChangeTurn", {turn = result})
end

local function onJoin()
	-- not waiting anymore!
	-- start the game from GUI
	msg.post(gui_controller, "start_game")
end

-- #Connect to the room
local function connect(self)
	-- Join Room
	room = client:join("tictactoe")

	-- Listen to room state changes from the room handler.
	-- Use this method to synchronize the room state from the server with the clients.
	room:listen(
		"players/:id",
		function(change)
			print("players/:id")
			numPlayers = numPlayers + 1
			if numPlayers == 2 then
				onJoin()
			end
		end
	)

	room:listen(
		"currentTurn",
		function(change)
			print("currentTurn")
			pprint(change["value"])
			self.change_value = change["value"]
			timer.delay(0.2, false, nextTurn)
			--nextTurn(change.value)
		end
	)

	room:listen(
		"board/:x/:y",
		function(change)
			if change["operation"] == "replace" then
				msg.post(gui_controller, "ChangeTile", {change = change})
			end
		end
	)

	room:listen(
		"draw",
		function(change)
			print("draw")
			if change["operation"] == "replace" then
				drawGame()
			end
		end
	)

	room:listen(
		"winner",
		function(change)
			if change["operation"] == "add" then
				showWinner(change["value"])
			end
		end
	)

	room:on(
		"error",
		function(err)
			print("oops, error ocurred:")
			print(err)
		end
	)
end

function init(self)
	-- Connect to WS
	client = ColyseusClient.new("ws://localhost:3553")

	-- EVENTS
	-- #open
	client:on(
		"open",
		function()
			print("onopen emitted")
		end
	)

	-- #message
	client:on(
		"message",
		function(message)
			print("message emitted")
		end
	)

	-- #error
	client:on(
		"error",
		function(err)
			print("error emitted")
			pprint(err)
			msg.post(gui_controller, "connection_fail")
		end
	)

	-- #close
	client:on(
		"close",
		function()
			print("connection has been closed")
			msg.post(gui_controller, "connection_fail")
		end
	)

	-- Connect to the room
	connect(self)
end

function final(self)
	-- Add finalization code here
	-- Remove this function if not needed
end

function update(self, dt)
	-- #loop ?
	client:loop()
end

function on_message(self, message_id, message, sender)
	if message_id == hash("SetTile") then
		onSelect(message.x, message.y)
	end
end

function on_input(self, action_id, action)
	-- Add input-handling code here
	-- Remove this function if not needed
end

function on_reload(self)
	-- Add reload-handling code here
	-- Remove this function if not needed
end
